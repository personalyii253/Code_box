创建索引的列最好不要有空值
1.普通索引：它没有唯一性之类的限制.可以考虑使用索引的主要有两种类型的列：在WHERE子句中出现的列，在join子句中出现的列
	创建普通索引：CREATE  INDEX 索引名称 ON 表名(列名[length])
	修改表的那一列的索引如果没有就创建，例如ALTER TABLE tablename ADD INDEX [索引的名字] (列的列表)
	创建表的时候指定索引，例如CREATE TABLE tablename ( [...],INDEX [索引的名字] (列的列表) )；

2.唯一索引:索引列的所有值都只能出现一次，即必须唯一.可以考虑使用索引的主要有两种类型的列：在WHERE子句中出现的列，在join子句中出现的列
	创建索引:CREATE UNIQUE INDEX 索引的名字 ON 表名(列名)
	修改表，例如ALTER TABLE tablename ADD UNIQUE [索引的名字] (列的列表[length])；
	创建表的时候指定索引，例如CREATE TABLE tablename ( [...],UNIQUE [索引的名字] (列的列表) )；

3.主键索引:主键是一种唯一性索引，但它必须指定为“PRIMARY KEY”，其实就是在创建表的时候我们设计了一个主键，那么MySQL会自动的为这个主键创建一个索引，同时这个索引会删除不了.


4.复合索引:就是几个字段联合在一起组成一个索引,可以考虑使用索引的主要有两种类型的列：在WHERE子句中出现的列，在join子句中出现的列
	创建:create index 索引名 on 表名(字段名[length],字段名[length])	
注意：创建了复合索引以后，如果仅用复合索引的非起始列(就是这几个字段要组合在一起创建一个复合索引，那么这几个字段在创建索引的语法中从第二个字段名开始往后就是非起始列)作为查询条件的话，这个复合索引是不起任何作用的,而且无论是否经常使用这个聚合索引的其他列，但其起始列一定要是使用最频繁的列。所以，在使用这个聚合索引的时候，这个起始列必须存在，否则这个复合索引会找不到。比如在创建某个复合索引的时候，是这么创建的 CREATE  INDEX 索引名称 ON 表名(firstname，lastname，age)，那么使用这个复合索引的时候，只可以firstname，lastname，age  || firstname，lastname || firstname 这样子使用，从另一方面理解，它相当于我们创建了(firstname，lastname，age)、(firstname，lastname)以及(firstname)这些列组合上的索引.例如下面这些查询就可以使用到这个复合索引
  	SELECT peopleid FROM people 
 
	WHERE firstname='Mike' AND lastname='Sullivan' AND age='17'; 
 
	SELECT peopleid FROM people WHERE firstname='Mike' AND lastname='Sullivan'; 
 
SELECT peopleid FROM people WHERE firstname='Mike';
总之，创建了复合索引之后，在使用这个复合索引的时候，创建这个复合索引的起始列必须存在这个复合索引才会被找到并使用.但是，有时候并不是只要起始列存在，这个复合索引就会被使用,就拿上面那个例子来说，如果是firstname单独出现这个复合索引会被使用，firstname和lastname同时出现这个复合索引也会被使用，firstname和lastname和age同时出现这个复合索引也会被使用，但是，如果是firstname和age同时出现，那么就不会找到这个复合索引，也不会被使用，要是lastname和age同时出现，也不会找到这个复合索引，也不会被使用，要是lastname和age其中一个单独出现，也不会找到这个复合索引，也不会被使用，因为，要想找到这个复合索引首先要拿这个字段名与要使用的复合索引的起始列进行比较，若是不相等，则不能使用这个复合索引，若相等，则看看sql语句中这个字段名后面还有没有其他字段名，若有，则继续与起始列后面的那一个列名进行比较，若相等，则可以使用，否则不可以使用，若还有其它字段名，但是这时起始列后面的那一列的后面没有列名了，那么就可以使用这个复合索引了，若是起始列后面的那一列的后面还有列，则再拿这个其它字段名与起始列后面的那一列的后面的那一列进行比较，若相等则可以使用这个复合索引，否则不可以使用这个复合索引，以此类推，若这个sql语句中只有这一个字段名并且与要使用的复合索引的起始列相同，则这个sql语句就可以直接使用这个复合索引.

5.删除索引:DROP INDEX index_name ON table

6.当数据多且字段值有相同的值得时候用普通索引，当字段多且字段值没有重复的时候用唯一索引,当有多个字段名都经常被查询的话用复合索引，普通索引不支持空值，唯一索引支持空值，但是，若是这张表增删改多而查询较少的话，就不要创建索引了，因为如果你给一列创建了索引，那么对该列进行增删改的时候，都会先访问这一列的索引，若是增，则在这一列的索引内以新填入的这个字段名的值为名创建索引的子集，若是改，则会把原来的删掉，再添入一个以这个字段名的新值为名创建索引的子集，若是删，则会把索引中以这个字段为名的索引的子集删掉。所以，会对增删改的执行减缓速度，所以，若是这张表增删改多而查询较少的话，就不要创建索引了。更新太频繁地字段不适合创建索引。不会出现在where条件中的字段不该建立索引.

7.当给一个字段创建了索引的话，而这个字段要进行like模糊查询的话，那么这个值左边不可以有%，因为索引查询是要从左到右的，你如果给它加上%后，左边的值不是确定的话，它会找不到这个索引。所以在使用like模糊查询的时候，值得左边不可以有%.

8.全文检索：全文检索就是FULLTEXT，用于 MyISAM 表，在列类型为 CHAR、VARCHAR 或 TEXT 列上创建，将数据装载到一个没有 FULLTEXT 索引的表中，然后再使用 ALTER TABLE (或 CREATE INDEX) 创建索引，这将是非常快的。将数据装载到一个已经有 FULLTEXT 索引的表中，将是非常慢的。MySQL自带的全文索引只能对英文进行全文检索。要检索中文用sphinx.
	创建全文检索：alter table 表名 add fulltext index 索引名(列名,[列名]，[列名]..)；（可以有多个，可以有一个）
	在创建表的时候建全文检索：CREATE TABLE article (
    	  id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    	  FULLTEXT (title, content) --在title和content列上创建全文索引
	   );

	使用全文检索:SELECT * FROM article WHERE MATCH('设置了全文检索的列名') against('查询字符串')  


9.hash索引和btree索引的区别:
     a. hash索引查找数据基本上能一次定位数据，当然有大量碰撞的话性能也会下降。而btree索引就得在节点上挨着查找了，很明显在数据精确查找方面hash索引的效率是要高于btree的.

     b. 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；

     c. 对于btree支持的联合索引的最优前缀，hash也是无法支持的，联合索引中的字段要么全用要么全不用。

     d. hash不支持索引排序，索引值和计算出来的hash值大小并不一定一致。

     e.hash索引是一个算法，而btree索引是一个b型二叉树形图.就是每一个树形图的子集中只有一个数据.
		例如:    A
		      B     C
		   D          E
10.rtree索引目前只支持geomatry数据库.并且rtree是r型树形图.就是每一个树形图的子集中都有多个数据.
 		例如:       A B C
		     d e f         g i g
	      k l m                      n o p
11:查看某个表的索引:show index from 表名
12.聚集索引和非聚集索引是sqlserver的.
13.在创建索引的时候，若是在列名后面加上length，则会将这个length经过一定的算法，再利用这个计算出来的结果去这个列名下面每一行的值中，与这些值得长度进行匹配，会把匹配到的值得长度所对应的值给设成索引，例如那个length是1，而值是山西，则只会给山创建索引（只是这个道理，具体这个length会进行计算，然后拿结果和值得长度比较），若是没有写length，则会根据创建表的时候给这个字段的长度当成列名后面的length，然后计算后进行匹配，匹配到的建立索引，也就是会给这个列下的每一行值创建索引.